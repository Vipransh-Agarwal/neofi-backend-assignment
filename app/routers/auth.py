from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from ..schemas import UserCreate, UserRead, Token
from ..models import User
from ..db.session import get_db
from ..core.security import (
    get_password_hash,
    verify_password,
    create_access_token,
)
from ..dependencies import get_current_user

router = APIRouter(prefix="/api/auth", tags=["auth"])


@router.post("/register", response_model=UserRead, status_code=status.HTTP_201_CREATED)
async def register_user(user_in: UserCreate, db: AsyncSession = Depends(get_db)):
    # 1) Check for existing username or email
    result = await db.execute(
        select(User).where(
            (User.username == user_in.username) | (User.email == user_in.email)
        )
    )
    existing_user = result.scalar_one_or_none()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Username or email already registered",
        )

    # 2) Hash password and create User instance
    hashed_pw = get_password_hash(user_in.password)
    new_user = User(
        username=user_in.username,
        email=user_in.email,
        password_hash=hashed_pw,
    )
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)  # refresh to get autogenerated fields (e.g. id, created_at)

    return new_user


@router.post("/login", response_model=Token)
async def login_for_access_token(user_in: UserCreate, db: AsyncSession = Depends(get_db)):
    # Weâ€™re reusing UserCreate for simplicity, but only username & password matter here
    result = await db.execute(select(User).where(User.username == user_in.username))
    user = result.scalar_one_or_none()
    if not user or not verify_password(user_in.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Create a JWT; put user.id in "sub"
    access_token = create_access_token(data={"sub": user.id}, expires_delta=timedelta(minutes=15))
    return {"access_token": access_token, "token_type": "bearer"}


@router.get("/me", response_model=UserRead)
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user